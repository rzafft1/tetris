from typing import Dict, List, Tuple
import pygame 
from src.controller import Controller
from src.shape import Shape
import copy 

# Type Aliases
Matrix = List[List[int]]
Color = Tuple[int, int, int]

# ===============================
# Constants and Mappings
# ===============================

COLORS: Dict[str, Tuple[int, int, int]] = {
    "BLACK":       (0, 0, 0),
    "WHITE":       (255, 255, 255),
    "GRAY":        (128, 128, 128),
    "LIGHT_GRAY":  (192, 192, 192),
    "DARK_GRAY":   (64, 64, 64),
    "RED":         (255, 0, 0),
    "GREEN":       (0, 255, 0),
    "BLUE":        (0, 0, 255),
    "YELLOW":      (255, 255, 0),
    "ORANGE":      (255, 165, 0),
    "PURPLE":      (128, 0, 128),
    "PINK":        (255, 192, 203),
    "MAGENTA":     (255, 0, 255),
    "CYAN":        (0, 255, 255),
    "LIME":        (0, 255, 128),
    "TEAL":        (0, 128, 128),
    "VIOLET":      (148, 0, 211),
    "TURQUOISE":   (64, 224, 208),
    "CORAL":       (255, 127, 80),
    "GOLD":        (255, 215, 0),
    "SALMON":      (250, 128, 114)
}

COLORS_MAPPING: Dict[int, Tuple[int, int, int]] = {
    1: COLORS["BLUE"],
    2: COLORS["YELLOW"],
    3: COLORS["PURPLE"],
    4: COLORS["PINK"],
    5: COLORS["ORANGE"],
    6: COLORS["RED"],
    7: COLORS["GREEN"]
}

class GameUI:

    """
    Represents the actual user interface (i.e. game window, game board, etc.).
    It manages the design of the game window, draws the game board, handles user
    input, and executes game ticks
    """

    # ===============================
    # Scaling Constants
    # ===============================
    SCALE_WINDOW = 0.99
    SCALE_GRID_CONTAINER = 0.97
    
    # ===============================
    # Colors
    # ===============================
    BACKGROUND_COLOR: Color = COLORS["BLACK"]
    GRID_BORDER_COLOR: Color = COLORS["WHITE"]
    GRID_CELL_COLOR: Color = COLORS["BLACK"]
    GRID_LINE_COLOR: Color = COLORS["BLACK"]
    CELL_BORDER_COLOR: Color = COLORS["WHITE"]
    HEADER_TEXT_COLOR: Color = COLORS["WHITE"]
    SUBHEADER_TEXT_COLOR: Color = COLORS["WHITE"]

    HEADER_FONT = "Courier New"
    SUBHEADER_FONT = "Courier New"
    
    def __init__(self, difficulty: int = 1):
        pygame.init()

        # ===============================
        # Game Controller and Initial Game Difficulty
        # ===============================
        self.starting_level = difficulty
        self.controller: Controller = Controller(initial_level=self.starting_level)
        self.previous_level = self.controller.level
        self.initial_level_speed = 500
        self.tick_interval = self.initial_level_speed
        self.update_tick_interval()

        # ===============================
        # Determine height and width of the user's screen and cut out a square
        # ===============================
        self.display_info = pygame.display.Info()
        screen_w, screen_h = self.display_info.current_w, self.display_info.current_h
        # Make window square
        if screen_w < screen_h:
            screen_h = screen_w
        else:
            screen_w = screen_h

        # ===============================
        # Dynamic padding variables (proportional to screen size)
        # ===============================
        self.padding_grid = {
            "left": screen_w * 0.01,
            "right": screen_w * 0.01,
            "top": 0,
            "bottom": 0
        }
        self.padding_sidebar = {
            "left": 0,
            "right": screen_w * 0.01,
            "top": 0,
            "bottom": 0
        }
        self.sidebar_box_spacing = screen_h * 0.01


        # ===============================
        # Calculate Dimensions
        # ===============================

        # Window dimensions
        self.height_window = screen_h * GameUI.SCALE_WINDOW

        # Size of a single block
        self.size_block = min(
            ((screen_h * GameUI.SCALE_WINDOW * GameUI.SCALE_GRID_CONTAINER) -
             (self.padding_grid["top"] + self.padding_grid["bottom"])) // self.controller.game_board.num_rows,
            ((screen_w * GameUI.SCALE_WINDOW * GameUI.SCALE_GRID_CONTAINER) -
             (self.padding_grid["left"] + self.padding_grid["right"])) // self.controller.game_board.num_cols
        )

        # Grid container
        self.width_grid_container = self.size_block * self.controller.game_board.num_cols
        self.height_grid_container = self.size_block * self.controller.game_board.num_rows

        # Sidebar container
        self.width_sidebar_container = self.size_block * 6
        self.height_sidebar_container = self.height_grid_container

        # Window width
        self.width_window = (
            self.width_grid_container + self.width_sidebar_container +
            self.padding_grid["left"] + self.padding_sidebar["right"] +
            self.padding_grid["right"]
        )
        
        # ===============================
        # Initialize the Game Window 'Surface'
        # ===============================

        self.surface = pygame.display.set_mode((int(self.width_window), int(self.height_window)))

    # ===============================
    # UI Rendering
    # ===============================


    def draw_ui(self) -> None:

        # ===============================
        # 1. Create grid container
        # ===============================
        grid_x = self.padding_grid["left"]
        grid_y = (self.height_window - self.height_grid_container) // 2
        grid_rect = pygame.Rect(grid_x, grid_y, self.width_grid_container, self.height_grid_container)

        # ===============================
        # 2. Create sidebar container
        # ===============================
        sidebar_x = grid_x + grid_rect.width + self.padding_grid["right"]
        sidebar_rect = pygame.Rect(sidebar_x, grid_y, self.width_sidebar_container, self.height_sidebar_container)
        pygame.draw.rect(self.surface, GameUI.GRID_BORDER_COLOR, sidebar_rect, 3) # NOTE: SCAFFOLDING

        # ===============================
        # 3. Draw sidebar boxes (3 boxes: 25%, 25%, 50%) with spacing of 1% of screen height
        # ===============================
        sidebar_total_height = self.height_sidebar_container - 2 * self.sidebar_box_spacing
        sidebar_containers = [
            pygame.Rect(
                sidebar_x,
                grid_y,
                self.width_sidebar_container,
                sidebar_total_height * 0.25
            ),
            pygame.Rect(
                sidebar_x,
                grid_y + sidebar_total_height * 0.25 + self.sidebar_box_spacing,
                self.width_sidebar_container,
                sidebar_total_height * 0.25
            ),
            pygame.Rect(
                sidebar_x,
                grid_y + sidebar_total_height * 0.5 + 2 * self.sidebar_box_spacing,
                self.width_sidebar_container,
                sidebar_total_height * 0.5
            )
        ]
        for rect in sidebar_containers:
            pygame.draw.rect(self.surface, GameUI.GRID_BORDER_COLOR, rect, 2) # NOTE: SCAFFOLDING

         
        # ===============================
        # 4. Draw the game board grid in the grid container
        # ===============================

        # Draw all cell colors
        for row in range(self.controller.game_board.num_rows):
            for col in range(self.controller.game_board.num_cols):
                x = grid_x + col * self.size_block
                y = grid_y + row * self.size_block
                square = pygame.Rect(x, y, self.size_block, self.size_block)
                cell_value = self.controller.game_board.grid[row][col]
                cell_color = COLORS_MAPPING.get(cell_value, GameUI.GRID_CELL_COLOR)
                pygame.draw.rect(self.surface, cell_color, square)

        # Draw grid lines
        for r in range(self.controller.game_board.num_rows + 1):
            y = grid_y + r * self.size_block
            pygame.draw.line(self.surface, GameUI.GRID_LINE_COLOR, (grid_x, y), (grid_x + grid_rect.width, y), 5)
        for c in range(self.controller.game_board.num_cols + 1):
            x = grid_x + c * self.size_block
            pygame.draw.line(self.surface, GameUI.GRID_LINE_COLOR, (x, grid_y), (x, grid_y + grid_rect.height), 5)

        # Draw grid border
        pygame.draw.rect(self.surface, GameUI.GRID_BORDER_COLOR, grid_rect, 1)

        return
        # ===============================
        # 5. Draw the game information in the 1st side bar container
        # ===============================

        GAMEINFO_PADDING_RATIO = 0.05  # 5% padding for text inside boxes

        # 5.1. Define the text content and styles
        gameinfo_texts = {
            1: {"value": "Title A", "font": GameUI.HEADER_FONT, "color": GameUI.HEADER_TEXT_COLOR, "bold": True},
            2: {"value": "0000000", "font": GameUI.SUBHEADER_FONT, "color": GameUI.SUBHEADER_TEXT_COLOR, "bold": False},
            3: {"value": "Title B", "font": GameUI.HEADER_FONT, "color": GameUI.HEADER_TEXT_COLOR, "bold": True},
            4: {"value": "1111111", "font": GameUI.SUBHEADER_FONT, "color": GameUI.SUBHEADER_TEXT_COLOR, "bold": False},
            5: {"value": "Title C", "font": GameUI.HEADER_FONT, "color": GameUI.HEADER_TEXT_COLOR, "bold": True},
            6: {"value": "2222222", "font": GameUI.SUBHEADER_FONT, "color": GameUI.SUBHEADER_TEXT_COLOR, "bold": False},
        }

        # 5.2. Split sidebar into 3 equal panels
        sidebar_gameinfo_container = sidebar_containers[0]
        num_panels = 3
        panel_height = sidebar_gameinfo_container.height // num_panels
        info_panels = [
            pygame.Rect(
                sidebar_gameinfo_container.left,
                sidebar_gameinfo_container.top + i * panel_height,
                sidebar_gameinfo_container.width,
                panel_height
            )
            for i in range(num_panels)
        ]

        # 5.3. Each panel: split into header/value boxes (60% / 40%)
        text_index = 1  # keys in gameinfo_texts start from 1
        for panel in info_panels:
            pygame.draw.rect(self.surface, COLORS["WHITE"], panel, 2)
            header_height = int(panel.height * 0.6)
            value_height = panel.height - header_height
            text_boxes = [
                pygame.Rect(panel.left, panel.top, panel.width, header_height),
                pygame.Rect(panel.left, panel.top + header_height, panel.width, value_height)
            ]

            # 5.4. Draw text in each box
            for rect in text_boxes:
                pygame.draw.rect(self.surface, COLORS["MAGENTA"], rect, 2)  
                text_info = gameinfo_texts[text_index]

                # 5.5. Render text to maximize its size inside a given rectangle.
                # - Automatically reduces font size until text fits both width and height.
                # - Vertically centers text and applies left/top padding.
                padding_x = int(rect.width * GAMEINFO_PADDING_RATIO)
                padding_y = int(rect.height * GAMEINFO_PADDING_RATIO)
                max_width = rect.width - 2 * padding_x
                max_height = rect.height - 2 * padding_y
                font_size = min(max_width, max_height)
                font = pygame.font.SysFont(text_info['font'], font_size, bold=text_info.get('bold', False))
                rendered_text = font.render(text_info['value'], True, text_info['color'])
                while (rendered_text.get_width() > max_width or rendered_text.get_height() > max_height) and font_size > 5:
                    font_size -= 1
                    font = pygame.font.SysFont(text_info['font'], font_size, bold=text_info.get('bold', False))
                    rendered_text = font.render(text_info['value'], True, text_info['color'])
                text_x = rect.left + padding_x
                text_y = rect.top + (rect.height - rendered_text.get_height()) // 2
                self.surface.blit(rendered_text, (text_x, text_y))

                text_index += 1

        # ===============================
        # 6. Draw hold shape in 2nd side bar container
        # ===============================
        sidebar_holdshape_container = sidebar_containers[1]
        if self.controller.hold_shape is None:
            matrix = copy.deepcopy(self.controller.active_shape.matrix)
        else:
            matrix = copy.deepcopy(self.controller.hold_shape.matrix)
        matrix = self.trim_matrix(matrix)  
        matrix_width = self.size_block * len(matrix[0])
        matrix_height = self.size_block * len(matrix)
        offset_x = sidebar_holdshape_container.left + (sidebar_holdshape_container.width - matrix_width) // 2
        offset_y = sidebar_holdshape_container.top + (sidebar_holdshape_container.height - matrix_height) // 2
        self.draw_shape(matrix, offset_x, offset_y, self.size_block)

        # ===============================
        # 7. Draw the shape queue in the 3rd side bar container
        # ===============================
        sidebar_queue_container = sidebar_containers[2]
        num_subcontainers = 3
        subcontainer_height = sidebar_queue_container.height // num_subcontainers
        subcontainers = [
            pygame.Rect(
                sidebar_queue_container.left,
                sidebar_queue_container.top + i * subcontainer_height,
                sidebar_queue_container.width,
                subcontainer_height
            )
            for i in range(num_subcontainers)
        ]
        for i, shape in enumerate(reversed(self.controller.shape_queue)):
            subcontainer = subcontainers[i]
            matrix = copy.deepcopy(shape.matrix)
            matrix = self.trim_matrix(matrix)  
            matrix_width = self.size_block * len(matrix[0])
            matrix_height = self.size_block * len(matrix)
            offset_x = subcontainer.left + (subcontainer.width - matrix_width) // 2
            offset_y = subcontainer.top + (subcontainer.height - matrix_height) // 2
            self.draw_shape(matrix, offset_x, offset_y, self.size_block)



    def draw_shape(self, matrix: Matrix, offset_x: int, offset_y: int, cell_size: int) -> None:
        """
        Draws a single shape at a given position

        Args:
        - Shape: the shape that will be drawn
        - int: top left x position in the window
        - int: top left y position in the window
        """
        for r, row in enumerate(matrix):
            for c, val in enumerate(row):
                if val != 0:
                    rect = pygame.Rect(offset_x + c * cell_size, offset_y + r * cell_size, cell_size, cell_size)
                    pygame.draw.rect(self.surface, COLORS_MAPPING[val], rect)
                    pygame.draw.rect(self.surface, GameUI.CELL_BORDER_COLOR, rect, 3)

    def trim_matrix(self, matrix: Matrix) -> Matrix:
        """
        Removes all rows and columns that are entirely zero.
        Args:
            matrix (Matrix): 2D list of integers representing a shape.
        Returns:
            Matrix: The trimmed matrix with no all-zero rows or columns.
        """
        if not matrix or not matrix[0]:
            return matrix # empty matrix, return as-is  
        # remove all-zero rows
        matrix = [row for row in matrix if any(cell != 0 for cell in row)]
        if not matrix:
            return matrix  # all rows were zero
        # Remove all-zero columns
        # Transpose, remove zero columns, transpose back
        matrix = [list(col) for col in zip(*matrix) if any(cell != 0 for cell in col)]
        matrix = [list(row) for row in zip(*matrix)]
        return matrix

    def update_tick_interval(self) -> None:
        """
        Update tick interval based on controller's level.
        - Each level will increase the speed of the tick interval by 10%, with max speed of 50ms
        """
        self.tick_interval = max(50, int(self.initial_level_speed * (0.9 ** (self.controller.level - 1))))
        TICK_EVENT = pygame.USEREVENT + 1
        pygame.time.set_timer(TICK_EVENT, self.tick_interval)


    # ===============================
    # Game Loop
    # ===============================
    def run(self) -> None:
        """
        Starts the game loop.
        - Processes user input
        - Advances the game via ticks
        - Draws the updated game state
        """
        TICK_EVENT = pygame.USEREVENT + 1
        pygame.time.set_timer(TICK_EVENT, self.tick_interval)

        running = True
        clock = pygame.time.Clock()
        side_move_delay = 70  # milliseconds between left/right moves
        down_move_delay = 25   # milliseconds between down moves
        last_move_time: Dict[int, int] = {pygame.K_LEFT: 0, pygame.K_RIGHT: 0, pygame.K_DOWN: 0}

        last_move_time: Dict[int, int] = {
            pygame.K_LEFT: 0,
            pygame.K_RIGHT: 0,
            pygame.K_DOWN: 0
        }

        while running:
            self.surface.fill(GameUI.BACKGROUND_COLOR)
            current_time = pygame.time.get_ticks()

            # ===============================
            # Event Handling
            # ===============================
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP:
                        self.controller.rotate()
                    if event.key == pygame.K_SPACE:
                        self.controller.hold_active_shape()
                elif event.type == TICK_EVENT:
                    running = self.controller.tick()
                    self.update_tick_interval()

                    if self.controller.level > self.previous_level:
                        print(f"Level up! Now Level {self.controller.level}")
                        self.previous_level = self.controller.level

            # ===============================
            # Handle held-down keys
            # ===============================
            keys = pygame.key.get_pressed()
            for key, direction in [(pygame.K_LEFT, "left"), 
                                (pygame.K_RIGHT, "right"), 
                                (pygame.K_DOWN, "down")]:
                delay = down_move_delay if direction == "down" else side_move_delay
                if keys[key] and current_time - last_move_time[key] > delay:
                    self.controller.move(direction)
                    last_move_time[key] = current_time

            # ===============================
            # Render
            # ===============================
            self.draw_ui()
            pygame.display.update()
            clock.tick(60)